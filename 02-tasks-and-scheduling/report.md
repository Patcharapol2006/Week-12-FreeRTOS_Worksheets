# Lab 1: Task Priority และ Scheduling
## คำถามสำหรับวิเคราะห์
1. Priority ไหนทำงานมากที่สุด? เพราะอะไร?
- Task ที่มี Priority สูงสุด (ตัวเลขมากที่สุด) เพราะ Scheduler แบบ Preemptive จะหยุด Task ที่ต่ำกว่าชั่วคราว เพื่อให้ Task ที่สูงกว่า (ที่อยู่ในสถานะ Ready) ได้รันก่อนเสมอ
2. เกิด Priority Inversion หรือไม่? จะแก้ไขได้อย่างไร?
- เกิดขึ้นได้ เมื่อ Task Priority สูง (H) ต้องรอทรัพยากร (เช่น Mutex) ที่ถูก Task Priority ต่ำ (L) ถือครองอยู่, และ Task Priority ปานกลาง (M) เข้ามาแทรก
- แก้ไขโดยใช้ Mutex ที่มีคุณสมบัติ Priority Inheritance (Task L จะถูกยก Priority ชั่วคราวให้เท่า Task H)
3. Tasks ที่มี priority เดียวกันทำงานอย่างไร?
- สลับกันทำงาน (แบ่งเวลา CPU) แบบ Round-Robin โดยจะสลับ Task เมื่อครบคาบเวลา (Time Slice / Tick) หรือเมื่อ Task นั้นๆ Block ตัวเอง (เช่น `vTaskDelay`)
4. การเปลี่ยน Priority แบบ dynamic ส่งผลอย่างไร?
- Scheduler จะจัดลำดับการทำงานใหม่ทันที (ณ Tick ถัดไป) Task ที่ถูกปรับให้สูงขึ้นอาจได้รันแซงคิว Task อื่น ส่วน Task ที่ถูกปรับลดอาจต้องหยุดรอ
5. CPU utilization ของแต่ละ priority เป็นอย่างไร?
- Task Priority สูงสุด (หากไม่ Block) จะมี CPU utilization สูงสุด เพราะได้รันก่อนเสมอ
- Task Priority ต่ำสุดจะได้รันก็ต่อเมื่อ Task อื่นที่ Priority สูงกว่าทั้งหมดอยู่ในสถานะ Blocked (เช่น `vTaskDelay` หรือรอ I/O)

# Lab 2: Task States Demonstration
## คำถามสำหรับวิเคราะห์
1. Task อยู่ใน Running state เมื่อไหร่บ้าง?
- เมื่อ Task นั้นถูก Scheduler เลือกให้ใช้งาน CPU (กำลังประมวลผลคำสั่ง) โดย Task นี้จะเป็น Task ที่มี Priority สูงสุดในบรรดา Task ทั้งหมดที่อยู่ในสถานะ Ready (พร้อมทำงาน)
2. ความแตกต่างระหว่าง Ready และ Blocked state คืออะไร?
- Ready (พร้อม): Task พร้อมทำงาน แต่กำลังรอคิว CPU (เพราะมี Task อื่นที่ Priority สูงกว่ากำลังรันอยู่)
- Blocked (ถูกบล็อก): Task ไม่พร้อมทำงาน เพราะกำลังรอเหตุการณ์บางอย่าง (เช่น `vTaskDelay`, รอ Queue, รอ Mutex)
3. การใช้ vTaskDelay() ทำให้ task อยู่ใน state ใด?
- ทำให้ Task ย้ายจาก Running ไปอยู่ในสถานะ Blocked (หยุดรอ) ตามระยะเวลาที่กำหนด เมื่อครบเวลา Task จะย้ายกลับไปสถานะ Ready เพื่อรอคิวรันต่อไป
4. การ Suspend task ต่างจาก Block อย่างไร?
- Blocked คือการหยุดรอชั่วคราวโดยมีเงื่อนไขปลดล็อกอัตโนมัติ (เช่น หมดเวลา, ได้รับข้อมูล)
- Suspend คือการ "แช่แข็ง" Task ไว้อย่างไม่มีกำหนด จนกว่าจะมีคำสั่ง `vTaskResume()` จาก Task อื่นมาปลุกเท่านั้น
5. Task ที่ถูก Delete จะกลับมาได้หรือไม่?
- ไม่ได้ครับ เมื่อ Task ถูกลบ (Delete) ทรัพยากรและหน่วยความจำ (Stack) ทั้งหมดจะถูกคืนให้ระบบ หากต้องการให้กลับมาทำงาน ต้องสร้างใหม่ด้วย `xTaskCreate()` เท่านั้น

# Lab 3: Stack Monitoring และ Debugging
## คำถามสำหรับวิเคราะห์
1. Task ไหนใช้ stack มากที่สุด? เพราะอะไร?
- Task ที่ เรียกฟังก์ชันซ้อนกันลึกๆ (Deep function call) หรือ ใช้ตัวแปร Local (ในฟังก์ชัน) ขนาดใหญ่ เพราะ Stack ถูกใช้เพื่อเก็บข้อมูล Context และตัวแปร Local ของฟังก์ชันที่ถูกเรียก
2. การใช้ heap แทน stack มีข้อดีอย่างไร?
- Heap (Dynamic Memory) ช่วยให้จองหน่วยความจำขนาดใหญ่ได้ตามต้องการ "ตอนรันไทม์" (เช่น `malloc`) ช่วยลดการใช้ Stack (ซึ่งมีขนาดคงที่และจำกัด) และป้องกัน Stack Overflow ได้
3. Stack overflow เกิดขึ้นเมื่อไหร่และทำอย่างไรป้องกัน?
- เกิดเมื่อ Task ใช้หน่วยความจำ Stack เกินกว่าขนาดที่จองไว้ (เช่น เรียกฟังก์ชันซ้อนลึกไป, ใช้ตัวแปร Local ขนาดใหญ่)
การป้องกันทำได้โดย:
- จอง Stack ให้พอ: ประเมินขนาดที่ต้องใช้ (High Water Mark) และเพิ่มเผื่อไว้
- หลีกเลี่ยง Recursion: หรือจำกัดความลึกของการเรียก
- ใช้ Heap: สำหรับตัวแปรหรือ Buffer ขนาดใหญ่
4. การตั้งค่า stack size ควรพิจารณาจากอะไร?
- พิจารณาจาก "ความลึก" สูงสุดของการเรียกฟังก์ชันซ้อน (Max Call Depth) และ "ขนาด" ของตัวแปร Local ทั้งหมด ที่ใช้ในทุกระดับการเรียกนั้น
5. Recursion ส่งผลต่อ stack usage อย่างไร?
- Recursion (การเรียกฟังก์ชันตัวเอง) จะสร้าง Stack Frame ใหม่ซ้อนทับไปเรื่อยๆ ในแต่ละรอบ ทำให้ Stack ถูกใช้งานเพิ่มขึ้นอย่างรวดเร็วและเสี่ยงต่อการเกิด Stack Overflow สูงมาก