# Lab 1: Basic Queue Operations (45 นาที)
### คำถามสำหรับการทดลอง
1. เมื่อ Queue เต็ม การเรียก `xQueueSend` จะเกิดอะไรขึ้น?
- Task ที่เรียก `xQueueSend` จะเข้าสู่สถานะ Blocked (หากระบุ `xTicksToWait` > 0) เพื่อรอจนกว่าจะมีพื้นที่ว่างใน Queue หรือจนกว่าจะหมดเวลา (Timeout)
- หากหมดเวลาแล้ว Queue ยังเต็มอยู่, หรือหาก `xTicksToWait` เป็น 0, ฟังก์ชันจะคืนค่า `pdFALSE` (ส่งไม่สำเร็จ) ทันที
2. เมื่อ Queue ว่าง การเรียก `xQueueReceive` จะเกิดอะไรขึ้น?
- Task ที่เรียก `xQueueReceive` จะเข้าสู่สถานะ Blocked (หากระบุ `xTicksToWait` > 0) เพื่อรอจนกว่าจะมีข้อมูลถูกส่งเข้ามาใน Queue หรือจนกว่าจะหมดเวลา (Timeout)
- หากหมดเวลาแล้ว Queue ยังว่างอยู่, หรือหาก `xTicksToWait` เป็น 0, ฟังก์ชันจะคืนค่า `pdFALSE` (รับไม่สำเร็จ) ทันที
3. ทำไม LED จึงกะพริบตามการส่งและรับข้อความ?
- เพราะ Queue ทำหน้าที่เป็นตัว Synchronization (บังคับจังหวะ)
- Task ที่ส่ง (Sender) จะถูกบังคับให้หยุดรอ (Block) เมื่อ Queue เต็ม และ Task ที่รับ (Receiver) จะหยุดรอเมื่อ Queue ว่าง การกะพริบ LED ในแต่ละ Task จึงเกิดขึ้นสอดคล้องกับจังหวะที่ข้อมูลถูกส่งและรับจริง

# Lab 2: Producer-Consumer System (45 นาที)
### คำถามสำหรับการทดลอง
1. ในทดลองที่ 2 เกิดอะไรขึ้นกับ Queue?
- Queue ทำหน้าที่เป็น Buffer (ที่พักข้อมูล) และ Decoupling (แยกส่วนการทำงาน) ระหว่าง Task
- ถ้า Producer (ผู้สร้างข้อมูล) ทำงานเร็วกว่า Consumer (ผู้ใช้ข้อมูล) → Queue จะเต็ม และ Producer จะถูก Block
- ถ้า Consumer ทำงานเร็วกว่า Producer → Queue จะว่าง และ Consumer จะถูก Block
2. ในทดลองที่ 3 ระบบทำงานเป็นอย่างไร?
- ระบบแสดงการทำงานแบบ Asynchronous Processing (การประมวลผลแบบไม่พร้อมกัน)
- Task หนึ่ง (Producer) สามารถสร้าง "งาน" (เช่น ข้อมูลเซ็นเซอร์) แล้วส่งเข้า Queue ได้ทันทีโดยไม่ต้องรอให้งานนั้นประมวลผลเสร็จ
- Task อื่นๆ (Consumers) จะดึงงานจาก Queue ไปประมวลผลในเบื้องหลัง ทำให้ Task หลักสามารถตอบสนองต่องานอื่นได้ทันที
3. Load Balancer แจ้งเตือนเมื่อไหร่?
- ในบริบทนี้ "Queue" ทำหน้าที่เป็น "Load Balancer" เอง
- มัน "แจ้งเตือน" (ส่งสัญญาณ) เมื่อระบบทำงานหนักเกินไป โดยการที่ Queue เต็ม
- เมื่อ `xQueueSend` ล้มเหลว (คืนค่า `pdFALSE`) นั่นคือสัญญาณบอก Task Producer ว่า Consumer ประมวลผลไม่ทันแล้ว

# Lab 3: Queue Sets Implementation (30 นาที)
### คำถามสำหรับการทดลอง
1. Processor Task รู้ได้อย่างไรว่าข้อมูลมาจาก Queue ไหน?
- Task ไม่ได้เรียก `xQueueReceive` ตรงๆ แต่จะเรียก `xQueueSelectFromSet()`
- ฟังก์ชันนี้จะ Block จนกว่า Queue ใดๆ ใน Set จะมีข้อมูล และ ค่าที่คืนกลับมา (Return Value) ก็คือ Handle ของ Queue ที่มีข้อมูลพร้อมให้อ่านนั่นเอง
2. เมื่อหลาย Queue มีข้อมูลพร้อมกัน เลือกประมวลผลอันไหนก่อน?
- Scheduler ไม่ได้การันตีลำดับ ระหว่าง Queue ที่พร้อมใน Set (มันจะคืน Handle ของ Queue ใดก็ได้ ที่พร้อม)
- อย่างไรก็ตาม ข้อมูล ภายใน Queue ที่ถูกเลือกนั้น จะยังคงถูกประมวลผลตามลำดับ FIFO (First-In, First-Out)
3. Queue Sets ช่วยประหยัด CPU อย่างไร?
- ช่วยกำจัดการ Polling (หรือ Busy-Waiting)
- แทนที่ Task จะต้องวนลูป `while(1)` เพื่อคอยเช็ค Queue ทีละอัน (ซึ่งกิน CPU ตลอดเวลา), `xQueueSelectFromSet` จะทำให้ Task เข้าสู่สถานะ Blocked (ไม่กิน CPU เลย)
- Task จะถูกปลุก (Wake up) ก็ต่อเมื่อมีข้อมูลเข้ามาใน Queue ใด Queue หนึ่งใน Set เท่านั้น